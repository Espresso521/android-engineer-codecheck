単一方向のデータフローを意識して作られました。

サーバーからデータを取得して、その結果をViewに表示するまでのデータの流れは以下のようになります。

Viewはデータ取得処理を行うためにUseCaseを呼び出します。
UseCaseはNetworkでサーバーからデータ取得を行なった後、その結果データをLocalStorageに保存します。
LocalStorageは自身の変更を購読しているStoreに対して変更を通知します。
Storeは自身の変更を購読しているViewに対して変更を通知します。

LocalStorageとNetworkと記載します。実際にはLocalStorageやNetworkはモジュールとしてはReposityからアクセスされる場合があります。

Viewはデータ取得処理を行うためにActionCreatorを呼び出します。
ActionCreatorはNetworkでサーバーからデータ取得を行ないます。
(オプション) ActionCreatorはオフライン対応が必要なデータの場合はLocalStorageに保存します。
ActionCreatorは結果データをActionとして作成し、Dispatcherに渡します。
DispatcherはActionをStoreに渡し、StoreはActionに応じて自身の状態を変更します。
Storeは自身の変更を購読しているViewに対して変更を通知します。

更に、1画面におけるViewロジックがPresenterに、ドメインロジックがUseCaseに集まる結果、Presenter/UseCaseが肥大化する傾向にあります。
これはプログラムにおける可読性の低下や運用保守性の低下に繋がります。
MVPの特性上ViewからPresenter間、PresenterからUseCase間を行き来することが多く、こちらも可読性を下げる原因になっていました。

Googleは公式にMVVMを推奨しており、LiveDataやViewModelなどのobserverパターンやデータストアの仕組みを公式ライブラリとして提供している点としても導入のハードルが低いです。
今回StoreはLiveDataを持つViewModelとして実装しています。

State
データ表示・イベントハンドリングのためのドメインモデル
Viewが直接バインドできるデータ
Intentで次の画面に渡すデータ
View
UIを表示する
Storeをobserveし、通知されたStateを元にViewにバインドする
イベントハンドリングをする
イベントに応じてActionCreatorを呼ぶ
画面遷移を行う
Action
    Stateをペイロードとして持ち、Dispatcherに渡される
    ActionCreatorにより生成される
Store
    Stateを1つ保持する
    Dispatcherに自身を登録し、Actionが持つStateを通知する
Dispatcher
    渡されたActionを登録された全Storeに通知する
ActionCreator
    現在の状態やAPI、DBからのデータを元に新たなStateおよびActionを作成し、Dispatcherに渡す。必要に応じて1つのActionCreatorで複数のActionを作成することもある

ViewState
    Viewの表示するデータと一致するデータを保持する
    スコープはViewと同じ
    通常はオンメモリのデータ
    データの提供はPush型でもできる
NetworkDomainState
    全ユーザーの情報を含むシステム全体のドメインデータを保持する
    スコープはアプリの生存とは無関係
    サーバー上に保存されている
    データの提供は基本Pull型のみ

これにより上記のNetworkDomainStateから直接取ってくる場合の問題を解決できます。

    オフライン対応についてはLocalDomainStateを永続ストレージに保存すれば参照できる。

    データの再取得については、LocalDomainStateはPushでViewStateにデータを送ることができるので、
    更新時は全てを取得しなくても、必要な変更部分だけの差分を受け取ることができる。

    りすこふのちかんげんそく

状態管理というのは概念自体が曖昧で実装も多様です。それぞれ特徴はありますが絶対的な正解というのは存在しません。
またメリットやデメリットは大きな規模のプロジェクトを長期間運用しないと見えにくいです。そのため比較がかなり難しいと言えます。


Eightは個人向けという点もあり、PCよりアプリがメインで使用されています。そのためローカルストレージの利点を最大限に利用した構成です。

一方でSansanは法人向けということもあり、どちらかというとPC版がメインです。
そのためWeb Frontendに近いLocalDomainStateを使わない実装の方が適しているのかと思います。

Eightは、単なる名刺管理ツールではなく、ビジネスプラットフォームです。
人と人、人とサービス、人と企業の出会いを生み出し、 その出会いによって生まれる価値を最大化することをミッションとしています。

出会いからイノベーションを生み出す。